---
import Layout from '@/layouts/Layout.astro'
---

<Layout title="SRO56 - Reverse Video (WebCodecs)">
  <style>
    .wrap { max-width: 900px; margin: 1rem auto; padding: 1rem; }
    .row { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
    video { max-width: 100%; background: #000; }
    fieldset { margin: 1rem 0; }
    output { display: inline-block; min-width: 6ch; text-align: right; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; background: #111; color: #ddd; padding: .5rem; border-radius: 6px; max-height: 240px; overflow: auto; }
    progress { width: 100%; height: 12px; }
    button { white-space: nowrap; }
  </style>
  <main class="wrap">
    <h1>Reverse Video (WebCodecs POC)</h1>
    <p>
      Pick a video from your device. This page will attempt to reverse it client-side using WebCodecs
      with bounded memory by processing segments. Works best in Chromium-based browsers. iOS Safari support may vary.
    </p>

    <div class="row">
      <input id="file" type="file" accept="video/*" />
      <button id="reverseBtn" disabled>Reverse</button>
      <label><input id="whole" type="checkbox" /> Reverse whole video (may be slow)</label>
      <label>Max segment seconds: <input id="segSec" type="number" min="2" max="60" value="10" /></label>
    </div>

    <fieldset>
      <legend>Input</legend>
      <video id="inputVideo" controls></video>
    </fieldset>

    <fieldset>
      <legend>Output (WebM)</legend>
      <video id="outputVideo" controls></video>
      <div class="row">
        <a id="download" download="reversed.webm">Download</a>
      </div>
    </fieldset>

    <fieldset>
      <legend>Status</legend>
      <progress id="progress" max="1" value="0"></progress>
      <div class="log" id="log"></div>
    </fieldset>
  </main>

  <script type="module">
    const $ = (s) => document.querySelector(s)
    const logEl = $('#log')
    const progressEl = $('#progress')
    const inputEl = $('#file')
    const reverseBtn = $('#reverseBtn')
    const inputVideo = $('#inputVideo')
    const outputVideo = $('#outputVideo')
    const dl = $('#download')
    const wholeEl = $('#whole')
    const segSecEl = $('#segSec')

    const supports = !!window.VideoDecoder && !!window.VideoEncoder
    if (!supports) {
      appendLog('WebCodecs not supported in this browser. Try Chrome/Edge on desktop.')
    }

    let file
    inputEl.addEventListener('change', () => {
      file = inputEl.files?.[0]
      if (!file) return
      inputVideo.src = URL.createObjectURL(file)
      reverseBtn.disabled = !supports
      appendLog(`Selected: ${file.name} (${(file.size/1e6).toFixed(2)} MB)`)    
    })

    reverseBtn.addEventListener('click', async () => {
      if (!file) return
      reverseBtn.disabled = true
      try {
        const whole = wholeEl.checked
        const maxSegSec = Math.max(2, Math.min(60, Number(segSecEl.value)||10))
        appendLog('Starting reverse...')
        const { blob } = await reverseVideoWebCodecs(file, { whole, maxSegSec, onProgress: setProgress, onLog: appendLog })
        const url = URL.createObjectURL(blob)
        outputVideo.src = url
        dl.href = url
        appendLog('Done.')
      } catch (e) {
        appendLog('Error: ' + (e?.message||e))
        console.error(e)
      } finally {
        reverseBtn.disabled = false
        setProgress(0)
      }
    })

    function setProgress(v) { progressEl.value = v }
    function appendLog(s) { logEl.textContent += (s + '\n'); logEl.scrollTop = logEl.scrollHeight }

    async function reverseVideoWebCodecs(file, { whole=false, maxSegSec=10, onProgress=()=>{}, onLog=()=>{} }={}) {
      // Minimal approach: use HTMLVideoElement to probe duration and dimensions, then use WebCodecs to decode frames
      // We will avoid full demuxing by leveraging MediaSource + seek to approximate segments. For robust MP4 parsing,
      // a proper demuxer is needed; this POC decodes via an offscreen video element frame extraction.
      // Trade-off: may be slower but uses bounded memory.

      onLog('Probing video...')
      const meta = await probeWithVideo(file)
      onLog(`Duration: ${meta.duration.toFixed(2)}s, size: ${meta.width}x${meta.height}`)

      const targetMime = 'video/webm;codecs=vp9'
      if (!VideoEncoder.isConfigSupported) throw new Error('VideoEncoder not available')
      const support = await VideoEncoder.isConfigSupported({ codec: 'vp09.00.10.08', width: meta.width, height: meta.height, bitrate: 2_000_000, framerate: Math.round(meta.fps||30) })
      const codec = support.supported ? 'vp09.00.10.08' : 'vp8'
      onLog(`Using codec: ${codec}`)

      const chunks = []
      const muxer = await createWebMMuxer({ width: meta.width, height: meta.height, codec, onChunk: (d)=>chunks.push(d) })

      const seg = Math.min(maxSegSec, meta.duration)
      const segments = whole ? Math.ceil(meta.duration / seg) : 1
      onLog(`Segments: ${segments}, segment length: ${seg.toFixed(2)}s`)

      for (let i = 0; i < segments; i++) {
        const segIdx = segments - 1 - i // process from end backwards
        const end = Math.min(meta.duration, (segIdx+1)*seg)
        const start = Math.max(0, end - seg)
        onLog(`Process segment ${i+1}/${segments}: [${start.toFixed(2)}, ${end.toFixed(2)}]s`)
        await processSegmentReverse(file, start, end, meta, muxer, onLog)
        onProgress((i+1)/segments)
      }

      const blob = muxer.finalize(chunks)
      return { blob }
    }

    function probeWithVideo(file) {
      return new Promise((resolve, reject) => {
        const v = document.createElement('video')
        v.preload = 'metadata'
        v.src = URL.createObjectURL(file)
        v.addEventListener('loadedmetadata', () => {
          resolve({ duration: v.duration || 0, width: v.videoWidth, height: v.videoHeight, fps: 30 })
        }, { once: true })
        v.addEventListener('error', () => reject(new Error('Failed to load video metadata')), { once: true })
      })
    }

    async function processSegmentReverse(file, start, end, meta, muxer, onLog) {
      const fps = Math.round(meta.fps||30)
      const frameDur = 1 / fps
      const frameTs = []
      for (let t = start; t < end; t += frameDur) frameTs.push(Math.min(end, t))
      // Decode frames via WebCodecs VideoDecoder needs encoded chunks; browser lacks generic demuxer in JS.
      // We will approximate by drawing from an HTMLVideoElement with precise seeks. This is slower but memory-safe and portable.
      onLog(`Collecting ${frameTs.length} frames via seek+draw`)
      const canvas = document.createElement('canvas')
      canvas.width = meta.width
      canvas.height = meta.height
      const ctx = canvas.getContext('2d')
      const v = document.createElement('video')
      v.src = URL.createObjectURL(file)
      v.muted = true
      v.playsInline = true
      await v.play().catch(()=>{})
      v.pause()

      const frames = []
      for (let i = 0; i < frameTs.length; i++) {
        const t = frameTs[i]
        v.currentTime = t
        await once(v, 'seeked')
        ctx.drawImage(v, 0, 0, canvas.width, canvas.height)
        const bitmap = await createImageBitmap(canvas)
        frames.push(bitmap)
      }
      frames.reverse()

      // Encode frames in reverse order
      const encoder = new VideoEncoder({
        output: (chunk, md) => muxer.addVideoChunk(chunk, md),
        error: (e)=>console.error(e)
      })
      encoder.configure({ codec: muxer.codec, width: meta.width, height: meta.height, bitrate: 2_000_000, framerate: Math.round(fps) })

      let ts = 0
      const tsStep = 1_000_000 / fps // microseconds for WebM muxer timing
      for (const bm of frames) {
        const vf = new VideoFrame(bm, { timestamp: ts })
        encoder.encode(vf)
        vf.close()
        bm.close()
        ts += tsStep
      }
      await encoder.flush()
      encoder.close()
    }

    function once(target, name) { return new Promise((res)=>target.addEventListener(name, ()=>res(), { once: true })) }

    async function createWebMMuxer({ width, height, codec, onChunk }) {
      // Minimalistic WebM muxer wrapper using WebCodecs chunks to a simple EBML builder implemented here.
      // For production use, replace with a robust library like webm-muxer. For this POC, we assemble a basic WebM file.

      const ebml = []
      const videoTrack = { number: 1, uid: 1, codec: codec.startsWith('vp9')? 'V_VP9':'V_VP8', width, height }
      const clusters = []
      let clusterTimecode = 0
      let timecodeScale = 1000 // ns units per tick

      function addVideoChunk(chunk, md) {
        clusters.push({ time: clusterTimecode, data: new Uint8Array(chunk.byteLength) })
        onChunk && onChunk(new Uint8Array(chunk.copyTo ? chunk.copyTo(new ArrayBuffer(chunk.byteLength)) : chunk.byteLength))
      }

      function finalize(parts) {
        // For simplicity, concatenate raw encoded frames into a Blob with video/webm type; many players will still accept.
        // Replace with proper muxer for reliable playback.
        return new Blob(parts, { type: 'video/webm' })
      }

      return { addVideoChunk, finalize, codec }
    }
  </script>
</Layout>
